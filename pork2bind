#!/usr/bin/env node

const fs = require('fs').promises;
const path = require('path');
const https = require('https');

// Parse command line arguments
function parseArgs() {
    const args = process.argv.slice(2);
    const config = {
        mode: null,
        domains: [],
        to: process.cwd(),
        from: process.cwd(),
        includeNS: false,
        quiet: false,
        stdout: false
    };

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        
        if (arg === '--json') {
            config.mode = 'json';
        } else if (arg === '--bind') {
            config.mode = 'bind';
        } else if (arg === '--to') {
            config.to = args[++i];
        } else if (arg === '--from') {
            config.from = args[++i];
        } else if (arg === '--include-ns') {
            config.includeNS = true;
        } else if (arg === '--quiet') {
            config.quiet = true;
        } else if (arg === '--stdout') {
            config.stdout = true;
        } else if (arg === '--help' || arg === '-h') {
            showHelp();
            process.exit(0);
        } else if (!arg.startsWith('--')) {
            config.domains.push(arg);
        } else {
            console.error(`Unknown option: ${arg}`);
            process.exit(1);
        }
    }

    // Validation
    if (!config.mode) {
        console.error('Error: Must specify either --json or --bind');
        showHelp();
        process.exit(1);
    }

    if (config.domains.length === 0) {
        console.error('Error: Must specify at least one domain');
        process.exit(1);
    }

    return config;
}

function showHelp() {
    console.log(`
pork2bind - DNS Zone Management Tool

USAGE:
  pork2bind --json domain1.tld [domain2.tld ...] [--to directory]
  pork2bind --bind domain1.tld [domain2.tld ...] [--from directory] [--to directory]

MODES:
  --json    Fetch DNS records from Porkbun API and save as JSON files
  --bind    Convert JSON files to BIND zone files

OPTIONS:
  --to         Output directory (default: current directory)
  --from       Input directory for JSON files (default: current directory)
  --include-ns Include NS records in BIND output (default: filtered out)
  --quiet      Minimal output - only errors and warnings
  --stdout     Output data to stdout instead of files
  --help       Show this help message

EXAMPLES:
  # Fetch DNS data from Porkbun API
  pork2bind --json example.com other.com --to ./dns-cache

  # Convert to BIND zone files (filters NS records by default)
  pork2bind --bind example.com other.com --from ./dns-cache --to /etc/bind/zones
  
  # Include NS records in BIND output
  pork2bind --bind example.com --include-ns

  # Quiet operation for scripts
  pork2bind --json example.com --quiet

  # Output to stdout for piping
  pork2bind --json example.com --stdout > example.com.json
  pork2bind --bind example.com --stdout > db.example.com

ENVIRONMENT:
  Requires .env file with:
    PORKBUN_API_KEY=your_api_key
    PORKBUN_SECRET_KEY=your_secret_key
`);
}

// Logging functions that respect quiet mode
function log(message, config) {
    if (!config.quiet) {
        console.error(message);
    }
}

function logSuccess(message, config) {
    if (!config.quiet) {
        console.error(`✓ ${message}`);
    }
}

function logError(message, config) {
    console.error(`✗ ${message}`);
}

// Load environment variables
function loadEnv() {
    try {
        require('dotenv').config();
        
        const apiKey = process.env.PORKBUN_API_KEY;
        const secretKey = process.env.PORKBUN_SECRET_KEY;
        
        if (!apiKey || !secretKey) {
            console.error('Error: Missing PORKBUN_API_KEY or PORKBUN_SECRET_KEY in .env file');
            process.exit(1);
        }
        
        return { apiKey, secretKey };
    } catch (error) {
        console.error('Error: dotenv package not found. Install with: npm install dotenv');
        process.exit(1);
    }
}

// Test API connection with ping endpoint
function testAPIConnection(apiKey, secretKey) {
    return new Promise((resolve, reject) => {
        const postData = JSON.stringify({
            apikey: apiKey,
            secretapikey: secretKey
        });

        const options = {
            hostname: 'api.porkbun.com',
            path: '/api/json/v3/ping',
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(postData)
            }
        };

        const req = https.request(options, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                console.error(`API Test - Status: ${res.statusCode}`);
                console.error(`API Test - Response: ${data}`);
                try {
                    const response = JSON.parse(data);
                    resolve(response);
                } catch (e) {
                    reject(new Error(`API ping failed - not JSON: ${data}`));
                }
            });
        });

        req.on('error', reject);
        req.write(postData);
        req.end();
    });
}

// Fetch DNS records from Porkbun API
function fetchDNSRecords(domain, apiKey, secretKey) {
    return new Promise((resolve, reject) => {
        const postData = JSON.stringify({
            apikey: apiKey,
            secretapikey: secretKey
        });

        console.log(`Debug - API Key present: ${!!apiKey} (length: ${apiKey ? apiKey.length : 0})`);
        console.log(`Debug - Secret Key present: ${!!secretKey} (length: ${secretKey ? secretKey.length : 0})`);

        const options = {
            hostname: 'api.porkbun.com',
            path: `/api/json/v3/dns/retrieve/${domain}`,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(postData)
            }
        };

        const req = https.request(options, (res) => {
            console.error(`Status Code: ${res.statusCode}`);
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                console.error(`Raw Response: ${data.substring(0, 200)}...`);
                try {
                    const response = JSON.parse(data);
                    if (response.status === 'SUCCESS') {
                        resolve(response.records || []);
                    } else {
                        reject(new Error(`API Error: ${response.message || 'Unknown error'}`));
                    }
                } catch (e) {
                    reject(new Error(`Failed to parse API response: ${data}`));
                }
            });
        });

        req.on('error', reject);
        req.write(postData);
        req.end();
    });
}

// Generate BIND zone file from DNS records
function generateBindZone(domain, records, includeNS = false) {
    // Generate serial in YYYYMMDDHHMMSS format
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hour = String(now.getHours()).padStart(2, '0');
    const minute = String(now.getMinutes()).padStart(2, '0');
    const second = String(now.getSeconds()).padStart(2, '0');
    const serial = `${year}${month}${day}${hour}${minute}${second}`;
    
    // Filter records if needed
    let filteredRecords = records;
    if (!includeNS) {
        const originalCount = records.length;
        filteredRecords = records.filter(record => record.type !== 'NS');
        if (originalCount > filteredRecords.length) {
            console.error(`  Filtered out ${originalCount - filteredRecords.length} NS record(s)`);
        }
    }
    
    let zone = `$TTL 3600
$ORIGIN ${domain}.
@    IN    SOA    ns1.${domain}. admin.${domain}. (
                    ${serial}       ; Serial
                    3600            ; Refresh
                    1800            ; Retry
                    1209600         ; Expire
                    3600 )          ; Minimum TTL

`;

    // Sort records by type and name for cleaner output
    const sortedRecords = filteredRecords.sort((a, b) => {
        // First sort by type
        if (a.type !== b.type) return a.type.localeCompare(b.type);
        
        // For MX records, sort by priority, then by content for stable ordering
        if (a.type === 'MX') {
            const prioA = parseInt(a.prio || 10);
            const prioB = parseInt(b.prio || 10);
            if (prioA !== prioB) return prioA - prioB;
            // If same priority, sort by mail server name for consistency
            return a.content.localeCompare(b.content);
        }
        
        // For same type records, put @ first, then *, then alphabetical
        const nameA = a.name === '@' ? '0' : a.name === '*' ? '1' : a.name;
        const nameB = b.name === '@' ? '0' : b.name === '*' ? '1' : b.name;
        
        return nameA.localeCompare(nameB);
    });

    sortedRecords.forEach(record => {
        // Use @ for apex domain, otherwise just the subdomain name
        let name;
        if (record.name === '@' || record.name === domain) {
            name = '@';
        } else if (record.name.endsWith(`.${domain}`)) {
            // Strip the domain suffix for cleaner output
            name = record.name.slice(0, -(domain.length + 1));
        } else {
            name = record.name;
        }
        
        const ttl = record.ttl || 3600;
        
        // Format record based on type
        let content = record.content;
        if (record.type === 'MX') {
            content = `${record.prio || 10} ${record.content}`;
        } else if (record.type === 'TXT') {
            // Quote TXT record values
            content = `"${record.content}"`;
        }
        
        // Compact formatting - no excessive padding
        zone += `${name} IN ${record.type} ${content}\n`;
    });

    return zone;
}

// Ensure directory exists
async function ensureDirectory(dir) {
    try {
        await fs.access(dir);
    } catch {
        await fs.mkdir(dir, { recursive: true });
    }
}

// JSON mode: Fetch DNS records and save to JSON files
async function jsonMode(config) {
    const { apiKey, secretKey } = loadEnv();
    
    if (!config.stdout) {
        await ensureDirectory(config.to);
    }

    // Test API connection first
    log('Testing API connection...', config);
    try {
        await testAPIConnection(apiKey, secretKey);
        log('✓ API connection successful\n', config);
    } catch (error) {
        logError(`API connection failed: ${error.message}`, config);
        console.error('Please check your API credentials in .env file\n');
        return;
    }

    log(`Fetching DNS records for ${config.domains.length} domain(s)...`, config);
    
    for (const domain of config.domains) {
        try {
            log(`Fetching ${domain}...`, config);
            const records = await fetchDNSRecords(domain, apiKey, secretKey);
            
            const jsonData = JSON.stringify(records, null, 2);
            
            if (config.stdout) {
                // Output to stdout for piping
                console.log(jsonData);
                if (config.domains.length > 1) {
                    console.error('Warning: Multiple domains with --stdout will concatenate JSON objects');
                }
            } else {
                // Save to file
                const outputFile = path.join(config.to, `${domain}.json`);
                await fs.writeFile(outputFile, jsonData);
                logSuccess(`Saved ${records.length} records to ${outputFile}`, config);
            }
        } catch (error) {
            logError(`Failed to fetch ${domain}: ${error.message}`, config);
        }
    }
}

// BIND mode: Convert JSON files to BIND zone files
async function bindMode(config) {
    if (!config.stdout) {
        await ensureDirectory(config.to);
    }

    log(`Converting ${config.domains.length} domain(s) to BIND format...`, config);
    
    for (const domain of config.domains) {
        try {
            const inputFile = path.join(config.from, `${domain}.json`);
            
            // Read JSON file
            const jsonData = await fs.readFile(inputFile, 'utf8');
            const records = JSON.parse(jsonData);
            
            // Generate BIND zone
            const zoneContent = generateBindZone(domain, records, config.includeNS);
            
            if (config.stdout) {
                // Output to stdout for piping
                console.log(zoneContent);
                if (config.domains.length > 1) {
                    console.error('Warning: Multiple domains with --stdout will concatenate zone files');
                }
            } else {
                // Save to file
                const outputFile = path.join(config.to, `db.${domain}`);
                await fs.writeFile(outputFile, zoneContent);
                logSuccess(`Converted ${domain} (${records.length} records) to ${outputFile}`, config);
            }
        } catch (error) {
            if (error.code === 'ENOENT') {
                logError(`JSON file not found: ${path.join(config.from, domain + '.json')}`, config);
            } else {
                logError(`Failed to convert ${domain}: ${error.message}`, config);
            }
        }
    }
}

// Main function
async function main() {
    try {
        const config = parseArgs();
        
        if (config.mode === 'json') {
            await jsonMode(config);
        } else if (config.mode === 'bind') {
            await bindMode(config);
        }
        
        if (!config.quiet && !config.stdout) {
            console.error('Done!');
        }
    } catch (error) {
        console.error(`Error: ${error.message}`);
        process.exit(1);
    }
}

// Run the program
if (require.main === module) {
    main();
}

module.exports = { parseArgs, fetchDNSRecords, generateBindZone };
